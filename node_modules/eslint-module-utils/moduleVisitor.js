'use strict';
<<<<<<< HEAD
exports.__esModule = true;

=======

exports.__esModule = true;

/** @typedef {import('estree').Node} Node */
/** @typedef {{ arguments: import('estree').CallExpression['arguments'], callee: Node }} Call */
/** @typedef {import('estree').ImportDeclaration | import('estree').ExportNamedDeclaration | import('estree').ExportAllDeclaration} Declaration */

>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
/**
 * Returns an object of node visitors that will call
 * 'visitor' with every discovered module path.
 *
<<<<<<< HEAD
 * todo: correct function prototype for visitor
 * @param  {Function(String)} visitor [description]
 * @param  {[type]} options [description]
 * @return {object}
 */
exports.default = function visitModules(visitor, options) {
  // if esmodule is not explicitly disabled, it is assumed to be enabled
  options = Object.assign({ esmodule: true }, options);

  let ignoreRegExps = [];
  if (options.ignore != null) {
    ignoreRegExps = options.ignore.map(p => new RegExp(p));
  }

  function checkSourceValue(source, importer) {
    if (source == null) return; //?

    // handle ignore
    if (ignoreRegExps.some(re => re.test(source.value))) return;
=======
 * @type {(import('./moduleVisitor').default)}
 */
exports.default = function visitModules(visitor, options) {
  const ignore = options && options.ignore;
  const amd = !!(options && options.amd);
  const commonjs = !!(options && options.commonjs);
  // if esmodule is not explicitly disabled, it is assumed to be enabled
  const esmodule = !!Object.assign({ esmodule: true }, options).esmodule;

  const ignoreRegExps = ignore == null ? [] : ignore.map((p) => new RegExp(p));

  /** @type {(source: undefined | null | import('estree').Literal, importer: Parameters<typeof visitor>[1]) => void} */
  function checkSourceValue(source, importer) {
    if (source == null) { return; } //?

    // handle ignore
    if (ignoreRegExps.some((re) => re.test(String(source.value)))) { return; }
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5

    // fire visitor
    visitor(source, importer);
  }

  // for import-y declarations
<<<<<<< HEAD
=======
  /** @type {(node: Declaration) => void} */
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
  function checkSource(node) {
    checkSourceValue(node.source, node);
  }

  // for esmodule dynamic `import()` calls
<<<<<<< HEAD
  function checkImportCall(node) {
=======
  /** @type {(node: import('estree').ImportExpression | import('estree').CallExpression) => void} */
  function checkImportCall(node) {
    /** @type {import('estree').Expression | import('estree').Literal | import('estree').CallExpression['arguments'][0]} */
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
    let modulePath;
    // refs https://github.com/estree/estree/blob/HEAD/es2020.md#importexpression
    if (node.type === 'ImportExpression') {
      modulePath = node.source;
    } else if (node.type === 'CallExpression') {
<<<<<<< HEAD
      if (node.callee.type !== 'Import') return;
      if (node.arguments.length !== 1) return;

      modulePath = node.arguments[0];
    }

    if (modulePath.type !== 'Literal') return;
    if (typeof modulePath.value !== 'string') return;
=======
      // @ts-expect-error this structure is from an older version of eslint
      if (node.callee.type !== 'Import') { return; }
      if (node.arguments.length !== 1) { return; }

      modulePath = node.arguments[0];
    } else {
      throw new TypeError('this should be unreachable');
    }

    if (modulePath.type !== 'Literal') { return; }
    if (typeof modulePath.value !== 'string') { return; }
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5

    checkSourceValue(modulePath, node);
  }

  // for CommonJS `require` calls
<<<<<<< HEAD
  // adapted from @mctep: http://git.io/v4rAu
  function checkCommon(call) {
    if (call.callee.type !== 'Identifier') return;
    if (call.callee.name !== 'require') return;
    if (call.arguments.length !== 1) return;

    const modulePath = call.arguments[0];
    if (modulePath.type !== 'Literal') return;
    if (typeof modulePath.value !== 'string') return;
=======
  // adapted from @mctep: https://git.io/v4rAu
  /** @type {(call: Call) => void} */
  function checkCommon(call) {
    if (call.callee.type !== 'Identifier') { return; }
    if (call.callee.name !== 'require') { return; }
    if (call.arguments.length !== 1) { return; }

    const modulePath = call.arguments[0];
    if (modulePath.type !== 'Literal') { return; }
    if (typeof modulePath.value !== 'string') { return; }
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5

    checkSourceValue(modulePath, call);
  }

<<<<<<< HEAD
  function checkAMD(call) {
    if (call.callee.type !== 'Identifier') return;
    if (call.callee.name !== 'require' &&
        call.callee.name !== 'define') return;
    if (call.arguments.length !== 2) return;

    const modules = call.arguments[0];
    if (modules.type !== 'ArrayExpression') return;

    for (const element of modules.elements) {
      if (element.type !== 'Literal') continue;
      if (typeof element.value !== 'string') continue;

      if (element.value === 'require' ||
          element.value === 'exports') continue; // magic modules: http://git.io/vByan
=======
  /** @type {(call: Call) => void} */
  function checkAMD(call) {
    if (call.callee.type !== 'Identifier') { return; }
    if (call.callee.name !== 'require' && call.callee.name !== 'define') { return; }
    if (call.arguments.length !== 2) { return; }

    const modules = call.arguments[0];
    if (modules.type !== 'ArrayExpression') { return; }

    for (const element of modules.elements) {
      if (!element) { continue; }
      if (element.type !== 'Literal') { continue; }
      if (typeof element.value !== 'string') { continue; }

      if (
        element.value === 'require'
        || element.value === 'exports'
      ) {
        continue; // magic modules: https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#magic-modules
      }
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5

      checkSourceValue(element, element);
    }
  }

  const visitors = {};
<<<<<<< HEAD
  if (options.esmodule) {
    Object.assign(visitors, {
      'ImportDeclaration': checkSource,
      'ExportNamedDeclaration': checkSource,
      'ExportAllDeclaration': checkSource,
      'CallExpression': checkImportCall,
      'ImportExpression': checkImportCall,
    });
  }

  if (options.commonjs || options.amd) {
    const currentCallExpression = visitors['CallExpression'];
    visitors['CallExpression'] = function (call) {
      if (currentCallExpression) currentCallExpression(call);
      if (options.commonjs) checkCommon(call);
      if (options.amd) checkAMD(call);
=======
  if (esmodule) {
    Object.assign(visitors, {
      ImportDeclaration: checkSource,
      ExportNamedDeclaration: checkSource,
      ExportAllDeclaration: checkSource,
      CallExpression: checkImportCall,
      ImportExpression: checkImportCall,
    });
  }

  if (commonjs || amd) {
    const currentCallExpression = visitors.CallExpression;
    visitors.CallExpression = /** @type {(call: Call) => void} */ function (call) {
      if (currentCallExpression) { currentCallExpression(call); }
      if (commonjs) { checkCommon(call); }
      if (amd) { checkAMD(call); }
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
    };
  }

  return visitors;
};

/**
<<<<<<< HEAD
 * make an options schema for the module visitor, optionally
 * adding extra fields.
 */
function makeOptionsSchema(additionalProperties) {
  const base =  {
    'type': 'object',
    'properties': {
      'commonjs': { 'type': 'boolean' },
      'amd': { 'type': 'boolean' },
      'esmodule': { 'type': 'boolean' },
      'ignore': {
        'type': 'array',
        'minItems': 1,
        'items': { 'type': 'string' },
        'uniqueItems': true,
      },
    },
    'additionalProperties': false,
=======
 * make an options schema for the module visitor, optionally adding extra fields.
 * @type {import('./moduleVisitor').makeOptionsSchema}
 */
function makeOptionsSchema(additionalProperties) {
  /** @type {import('./moduleVisitor').Schema} */
  const base =  {
    type: 'object',
    properties: {
      commonjs: { type: 'boolean' },
      amd: { type: 'boolean' },
      esmodule: { type: 'boolean' },
      ignore: {
        type: 'array',
        minItems: 1,
        items: { type: 'string' },
        uniqueItems: true,
      },
    },
    additionalProperties: false,
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
  };

  if (additionalProperties) {
    for (const key in additionalProperties) {
<<<<<<< HEAD
=======
      // @ts-expect-error TS always has trouble with arbitrary object assignment/mutation
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
      base.properties[key] = additionalProperties[key];
    }
  }

  return base;
}
exports.makeOptionsSchema = makeOptionsSchema;

/**
<<<<<<< HEAD
 * json schema object for options parameter. can be used to build
 * rule options schema object.
 * @type {Object}
=======
 * json schema object for options parameter. can be used to build rule options schema object.
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
 */
exports.optionsSchema = makeOptionsSchema();
