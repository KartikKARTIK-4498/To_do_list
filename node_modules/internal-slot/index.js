'use strict';

<<<<<<< HEAD
var GetIntrinsic = require('get-intrinsic');
var has = require('has');
var channel = require('side-channel')();

var $TypeError = GetIntrinsic('%TypeError%');
=======
var hasOwn = require('hasown');
var channel = require('side-channel')();

var $TypeError = require('es-errors/type');
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5

var SLOT = {
	assert: function (O, slot) {
		if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
			throw new $TypeError('`O` is not an object');
		}
		if (typeof slot !== 'string') {
			throw new $TypeError('`slot` must be a string');
		}
		channel.assert(O);
<<<<<<< HEAD
=======
		if (!SLOT.has(O, slot)) {
			throw new $TypeError('`' + slot + '` is not present on `O`');
		}
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
	},
	get: function (O, slot) {
		if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
			throw new $TypeError('`O` is not an object');
		}
		if (typeof slot !== 'string') {
			throw new $TypeError('`slot` must be a string');
		}
		var slots = channel.get(O);
		return slots && slots['$' + slot];
	},
	has: function (O, slot) {
		if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
			throw new $TypeError('`O` is not an object');
		}
		if (typeof slot !== 'string') {
			throw new $TypeError('`slot` must be a string');
		}
		var slots = channel.get(O);
<<<<<<< HEAD
		return !!slots && has(slots, '$' + slot);
=======
		return !!slots && hasOwn(slots, '$' + slot);
>>>>>>> daf1795927da2d71e7fda32ee847e5794b9052d5
	},
	set: function (O, slot, V) {
		if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
			throw new $TypeError('`O` is not an object');
		}
		if (typeof slot !== 'string') {
			throw new $TypeError('`slot` must be a string');
		}
		var slots = channel.get(O);
		if (!slots) {
			slots = {};
			channel.set(O, slots);
		}
		slots['$' + slot] = V;
	}
};

if (Object.freeze) {
	Object.freeze(SLOT);
}

module.exports = SLOT;
